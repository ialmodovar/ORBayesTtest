---
title: "Objective Bayesian \\(t\\)-test for one and two mean comparison"
output: html_document
runtime: shiny
---

<style type="text/css">
  body{
  font-size: 13pt;
}
</style>

```{r setup, include=FALSE}
library(shiny)
library(readxl)
library(readODS)
library(openxlsx)
library(shinythemes)

##**********************
##* One sample mean inference
##***********************

coth <- function(x){(exp(2*x)+1)/(exp(2*x)-1)}

one.sample.t.test.bf <- function(x,mu0,p0 = 0.5){
  ## remove NA
  x <- x[!is.na(x)]
  xbar <- mean(x)
  n <- length(x)
  sx <- sd(x)
  tstat <- (xbar-mu0)/(sx/sqrt(n))
  nu <- n-1
  ## intrinsic bayes factor
  bfi <- sqrt(2*n) * (1+tstat^2/nu)^(-n/2) * tstat^2/nu *1/(1-exp(-tstat^2/nu))
  ## robust bayes factor
  bfr <-sqrt(2/(n+1)) * ((n-2)/(n-1)) * tstat^2 * (1+tstat^2/nu)^(-n/2)*(1-(1+2*tstat^2/(n^2-1))^(-(n-2)/2))^(-1)
  ## jeffreys
  bfj <- sqrt(pi*nu/2) * (1+tstat^2/nu)^(-(nu-1)/2)
  
  
  ## posterior distributions of H_0
  
  
  p1 <- 1-p0
  
  pH0i.data <- (1+p1/p0 * 1/bfi)^(-1)
  pH0r.data <- (1+p1/p0 * 1/bfr)^(-1)
  pH0j.data <- (1+p1/p0 * 1/bfj)^(-1)
  
  bfs <- data.frame(statistic=tstat,BF01 = c(bfi,bfr,bfj),log2BF01 = 2*log(c(bfi,bfr,bfj)),posterior = c(pH0i.data,pH0r.data,pH0i.data))
  
  names(bfs) <- c("t","\\( B_{01} \\)","\\( 2 \\log (B_{01}) \\)",paste("\\(P (H_0: \\mu =", mu0,"|data) \\)"))
  row.names(bfs) <- c("Intrinsic","Robust","Jeffreys")
  
  bfs 
}

one.sample.t.test.bf.sm <- function(xbar,sx,n,mu0,p0 = 0.5){
  tstat <- (xbar-mu0)/(sx/sqrt(n))
  nu <- n-1
  ## intrinsic bayes factor
  bfi <- sqrt(2*n) * (1+tstat^2/nu)^(-n/2) * tstat^2/nu *1/(1-exp(-tstat^2/nu))
  ## robust bayes factor
  bfr <-sqrt(2/(n+1)) * ((n-2)/(n-1)) * tstat^2 * (1+tstat^2/nu)^(-n/2)*(1-(1+2*tstat^2/(n^2-1))^(-(n-2)/2))^(-1)
  ## jeffreys
  bfj <- sqrt(pi*nu/2) * (1+tstat^2/nu)^(-(nu-1)/2)
  
  
  ## posterior distributions of H_0
  
  
  p1 <- 1-p0
  
  pH0i.data <- (1+p1/p0 * 1/bfi)^(-1)
  pH0r.data <- (1+p1/p0 * 1/bfr)^(-1)
  pH0j.data <- (1+p1/p0 * 1/bfj)^(-1)
  
  bfs <- data.frame(statistic=tstat,BF01 = c(bfi,bfr,bfj),log2BF01 = 2*log(c(bfi,bfr,bfj)),posterior = c(pH0i.data,pH0r.data,pH0i.data))
  
  names(bfs) <- c("t","\\( B_{01} \\)","\\( 2 \\log (B_{01}) \\)",paste("\\(P (H_0: \\mu =", mu0,"|data) \\)"))
  row.names(bfs) <- c("Intrinsic","Robust","Jeffreys")
  
  bfs 
}


##****************************
##* Two sample means comparison
##****************************


two.sample.t.test.bf <- function(x,y,paired=FALSE,mu0,p0 = 0.5,lambda =0, sigma2d = 1/3){
  
  if(paired){
    one.sample.t.test.bf(x-y,mu0 = mu0,p0 = p0)
  } else{
  x <- x[!is.na(x)]
  y <- y[!is.na(y)]
    s21 <- var(x)
    s22 <- var(y)
    xbar1 <- mean(x)
    xbar2 <- mean(y)
    n1 <- length(x)
    n2 <- length(y)
    n <- n1+n2
    nu <- n-2
    nd <- (1/n1+1/n2)
    
    Sp <- ((n1-1)*s21+(n2-1)*s22)/(nu)
    tstat <- (xbar1-xbar2)/sqrt(Sp*nd)
    
    bfj <-  sqrt(pi*1/nd/2) * (1+tstat^2/(nu))^(-(n-1)/2)
    bfi <- tstat^2* n/(nu)*sqrt(nd)* (1+tstat^2/nu)^(-(n-1)/2)*(coth(nd*tstat^2/(nu))+1)
    ##----
    d <- nd/4
    b <- max(abs(1/n1),abs(-1/n2))^(-2)/4
    bfr <- sqrt(8/(b+d)*nd) * (n-3) * (tstat^2/(4*nu)) * (1 + tstat^2/nu)^(-(n-1)/2) *(1 - (1 + tstat^2*nd/(2*nu*(b+d)))^(-(n-3)/2))^(-1)
    
    ne0 <- (max(abs(1/n1),abs(-1/n2)))^(-2)* 1/nd
    bft <- sqrt(ne0) * (1+tstat^2/nu)^(-n/2)
    
    bfs <- sqrt(n) * (1+tstat^2/nu)^(-n/2)
    
    ##
    
    postv <- 1+nd * sigma2d
    nc <- sqrt(nd/postv) * lambda
    bfg <- (dt(tstat,nu)/(dt(tstat/sqrt(postv),nu,nc)/sqrt(postv)))
    
    
    ## posterior distributions of H_0
    p1 <- 1-p0
    
    pH0i.data <- (1+p1/p0 * 1/bfi)^(-1)
    pH0r.data <- (1+p1/p0 * 1/bfr)^(-1)
    pH0j.data <- (1+p1/p0 * 1/bfj)^(-1)
    pH0t.data <- (1+p1/p0 * 1/bft)^(-1)
    pH0s.data <- (1+p1/p0 * 1/bfs)^(-1)
    pH0g.data <- (1+p1/p0 * 1/bfg)^(-1)
    
    
    bf.all <- data.frame(statistic=tstat,
                         BF01 = c(bfi,bfr,bfj,bft,bfs,bfg),
                         logBF01 = 2*log(c(bfi,bfr,bfj,bft,bfs,bfg)),
                         posterior = c(pH0i.data,pH0r.data,pH0j.data,pH0t.data,pH0s.data,pH0g.data))
    
    names(bf.all) <- c("t","\\( B_{01} \\)","\\(  2\\log (B_{01}) \\)",paste("\\(P (H_0: \\mu_1 -\\mu_2 = ", mu0,"|data) \\)"))
    row.names(bf.all) <- c("Intrinsic","Robust","Jeffreys","TESS","Schwarz","Gonen")
    
    bf.all 
  }
}

two.sample.t.test.bf.sm <- function(xbar1,s21,n1,xbar2,s22,n2,mu0,p0 = 0.5,lambda =0, sigma2d = 1/3)
{
  
  n <- n1+n2
  nu <- n-2
  nd <- (1/n1+1/n2)
  
  Sp <- ((n1-1)*s21+(n2-1)*s22)/(nu)
  tstat <- (xbar1-xbar2-mu0)/sqrt(Sp*nd)
  
  bfj <-  sqrt(pi*1/nd/2) * (1+tstat^2/(nu))^(-(n-1)/2)
  bfi <- tstat^2* n/(nu)*sqrt(nd)* (1+tstat^2/nu)^(-(n-1)/2)*(coth(nd*tstat^2/(nu))+1)
  ##----
  d <- nd/4
  b <- max(abs(1/n1),abs(-1/n2))^(-2)/4
  bfr <- sqrt(8/(b+d)*nd) * (n-3) * (tstat^2/(4*nu)) * (1 + tstat^2/nu)^(-(n-1)/2) *(1 - (1 + tstat^2*nd/(2*nu*(b+d)))^(-(n-3)/2))^(-1)
  
  ne0 <- (max(abs(1/n1),abs(-1/n2)))^(-2)* 1/nd
  bft <- sqrt(ne0) * (1+tstat^2/nu)^(-n/2)
  
  bfs <- sqrt(n) * (1+tstat^2/nu)^(-n/2)
  
  ##
  
  postv <- 1+nd * sigma2d
  nc <- sqrt(nd/postv) * lambda
  bfg <- (dt(tstat,nu)/(dt(tstat/sqrt(postv),nu,nc)/sqrt(postv)))
  
  
  ## posterior distributions of H_0
  p1 <- 1-p0
  
  pH0i.data <- (1+p1/p0 * 1/bfi)^(-1)
  pH0r.data <- (1+p1/p0 * 1/bfr)^(-1)
  pH0j.data <- (1+p1/p0 * 1/bfj)^(-1)
  pH0t.data <- (1+p1/p0 * 1/bft)^(-1)
  pH0s.data <- (1+p1/p0 * 1/bfs)^(-1)
  pH0g.data <- (1+p1/p0 * 1/bfg)^(-1)
  
  
  bf.all <- data.frame(statistic=tstat,
                       BF01 = c(bfi,bfr,bft,bfj,bfs,bfg),
                       logBF01 = 2*log(c(bfi,bfr,bft,bfj,bfs,bfg)),
                       posterior = c(pH0i.data,pH0r.data,pH0t.data,pH0j.data,pH0s.data,pH0g.data))
  
  names(bf.all) <- c("t","\\( B_{01} \\)","\\(  2\\log (B_{01}) \\)",paste("\\(P (H_0: \\mu_1 -\\mu_2 = ", mu0,"|data) \\)"))
  row.names(bf.all) <- c("Intrinsic","Robust","TESS","Jeffreys","Schwarz","Gonen")
  
  bf.all 
}
```

## Introduction

Student's $t$ has been over 100 years since the discovery of one of the most fundamental statistical tests: the Student's $t$ test. In this shiny app, employs the objective and robust Bayesian approach for hypothesis testing for one-sample and two-sample mean comparisons for the assumption of equal variances.

```{r bayesian-t-test, echo=FALSE}
fluidPage(
  theme = shinytheme("flatly"),
  withMathJax(),
  tabsetPanel(
    tabPanel("Data",
             sidebarLayout(
               sidebarPanel(
                 radioButtons("upload_method", "Select Data Input Method:",
                              choices = c("Upload File" = "file", 
                                          "Manual Entry" = "manual")),
                 conditionalPanel(
                   condition = "input.upload_method == 'file'",
                   fileInput("file1", "Choose file", accept = c(".csv", ".xlsx", ".xls", ".ods"))
                 ),
                 conditionalPanel(
                   condition = "input.upload_method == 'manual'",
                   textAreaInput("manual_data", "Input data (including header)", "", rows = 8),
                   downloadButton("download", "Download .csv"),
                   br(),
                   downloadButton("download2", "Download .xlsx/.xls"),
                   br(),
                   downloadButton("download3", "Download .ods")
                 )
               ),
               mainPanel(tableOutput("contents"))
             )
    ),
    tabPanel("One Sample Inference",
             sidebarLayout(
               sidebarPanel(
                 radioButtons(inputId = "one_sample_options",label = "One Sample options", choices=c("Data" = "upload_input_data",
                                                                                                     "Summaries" = "one_summary")),
                 conditionalPanel(condition="input.one_sample_options=='upload_input_data'",
                                  uiOutput("var_select_one_sample_ui")),
                 conditionalPanel(condition="input.one_sample_options=='one_summary'",withMathJax(),
                                  numericInput(inputId = "one.sample.n",label = "Sample size \\( n\\)",value = 1),
                                  numericInput(inputId = "one.sample.mean",label = "Sample mean \\( \\bar{x}\\)",value = 0),
                                  numericInput(inputId = "one.sample.std",label = "Sample standard deviation \\( s\\)",value = 1),
                                  actionButton("run_one_sm", "Run one sample summary")
                                  
                 ),
               ),
               mainPanel(
                 conditionalPanel(
                   condition = "input.one_sample_options == 'upload_input_data'",
                   withMathJax(),
                   uiOutput("UIone_sample")
                 ),
                 
                 conditionalPanel(
                   condition = "input.one_sample_options == 'one_summary'",
                   withMathJax(),
                   uiOutput("UIone_sm")
                 )
               )
             )
    ),
    tabPanel("Two Sample Inference",
             sidebarLayout(
               sidebarPanel(
                 uiOutput("var_select_two_sample_ui"),
                 numericInput("lambda", label = withMathJax("\\(\\lambda\\): Effect size under \\( H_1 \\)"), value = 0, step = 0.1),
                 numericInput("sigma2d", label = withMathJax("\\(\\sigma^2_d\\): Prior variance"), value = 1/3, step = 0.1),
                 
                 actionButton("run_two", "Run Two Sample Test")
               ),
               mainPanel(
                 conditionalPanel(condition = "input.two_sample_options == 'two_samples_data'",
                                  withMathJax(),
                 uiOutput("UItwo_sample")
                 ),
                  conditionalPanel(
                   condition = "input.two_sample_options == 'two_summary'",
                   withMathJax(),
                   uiOutput("UItwo_sm")
                 )
                 )
             )
    )
  )
)

# ---- Data input ----
  mydata <- reactiveVal(NULL)
  
  observeEvent({
    input$file1
    input$manual_data
    input$upload_method
  }, {
    req(input$upload_method)
    
    if (input$upload_method == "file" && !is.null(input$file1)) {
      ext <- tools::file_ext(input$file1$name)
      df <- switch(ext,
                   csv = read.csv(input$file1$datapath),
                   xlsx = read_excel(input$file1$datapath),
                   xls  = read_excel(input$file1$datapath),
                   ods  = read_ods(input$file1$datapath),
                   NULL)
      mydata(df)
    } else if (input$upload_method == "manual") {
      tryCatch({
        df <- read.csv(text = input$manual_data)
        mydata(df)
      }, error = function(e) {
        showNotification("Error reading manual input.", type = "error")
      })
    }
  })
  
  output$contents <- renderTable({
    head(mydata(), 15)
  })
  
  output$download <- downloadHandler(
    filename = function() "manual_input.csv",
    content = function(file) {
      write.csv(mydata(), file, row.names = FALSE)
    }
  )
  
  output$download2 <- downloadHandler(
    filename = function() "manual_input.xlsx",
    content = function(file) {
      wb <- createWorkbook()
      addWorksheet(wb, "Sheet 1")
      writeData(wb, sheet = "Sheet 1", mydata(), rowNames = FALSE)
      saveWorkbook(wb, file, overwrite = TRUE)
    }
  )
  
  output$download3 <- downloadHandler(
    filename = function() "manual_input.ods",
    content = function(file) {
      write_ods(mydata(), file, row_names = FALSE)
    }
  )
  
# ---- One sample inference ----
  
  output$var_select_one_sample_ui <- renderUI({
    df <- mydata()
    req(df)
    num_vars <- names(df)[sapply(df, is.numeric)]
    selectInput("num.vars", "Select numerical variables:", choices = num_vars, multiple = TRUE)
  })
  
  output$UIone_sample <- renderUI({
    req(input$num.vars)
    df <- mydata()
    var_list <- input$num.vars
    
    lapply(var_list, function(varname) {
      safe_varname <- gsub("[^a-zA-Z0-9]", "_", varname)
      t_output_id <- paste0("mean_", safe_varname)
      mu_input_id <- paste0("mu0_", safe_varname)
      p0_id <- paste0("p0_", safe_varname)
      stats_id <- paste0("stats_", safe_varname)
      
      output[[t_output_id]] <- renderTable({
        req(df[[varname]], input[[mu_input_id]], input[[p0_id]])
        mu0 <- as.numeric(input[[mu_input_id]])
        p0 <- as.numeric(input[[p0_id]])
        x <- df[[varname]]
        one.sample.t.test.bf(x = x, mu0 = mu0, p0 = p0)
      }, rownames = TRUE, digits = 5)
      
      output[[stats_id]] <- renderUI({
        x <- df[[varname]]
        m <- mean(x, na.rm = TRUE)
        s <- sd(x, na.rm = TRUE)
        n <- sum(!is.na(x))
        
        withMathJax(HTML(
          paste0(
            "<table class='table'>",
            "<tr><td>\\( \\bar{x} = \\)</td><td>", round(m, 3), "</td></tr>",
            "<tr><td>\\( s = \\)</td><td>", round(s, 3), "</td></tr>",
            "<tr><td>\\( n = \\)</td><td>", n, "</td></tr>",
            "</table>"
          )
        ))
      })
      
      tagList(
        tags$h4(paste("Variable:", varname)),
        fluidRow(
          column(6, textInput(mu_input_id, label = withMathJax(paste0("\\( H_0: \\mu = \\mu_0 \\) for ", varname)), value = "0")),
          column(6, sliderInput(p0_id, label = withMathJax("Prior probability \\(P(H_0)\\)"), min = 0, max = 1, value = 0.5, step = 0.01))
        ),
        uiOutput(stats_id),
        tableOutput(t_output_id),
        tags$hr()
      )
    })
  })
  
  ##******
  ##* summary one sample
  ##*******
  
 output$UIone_sm <- renderUI({
  tagList(
    fluidRow(
      column(6, numericInput("mu0_sm", label = withMathJax("\\( H_0: \\mu = \\mu_0 \\)"), value = 0)),
      column(6, sliderInput("p0_sm", label = withMathJax("Prior probability \\(P(H_0)\\)"), min = 0, max = 1, value = 0.5, step = 0.01))
    ),
    tableOutput("one_summary_result"),
    tags$hr()
  )
})

output$one_summary_result <- renderTable({
  req(input$one.sample.mean, input$one.sample.std, input$one.sample.n, input$mu0_sm, input$p0_sm)
  
  one.sample.t.test.bf.sm(
    xbar = input$one.sample.mean,
    sx = input$one.sample.std,
    n = input$one.sample.n,
    mu0 = input$mu0_sm,
    p0 = input$p0_sm
  )
}, rownames = TRUE, digits = 5)

# ---- Two sample inference ----
  
  output$var_select_two_sample_ui <- renderUI({
  tagList(
    radioButtons("two_sample_options", "Select option:",
                 choices = c("Data Input" = "two_samples_data", "Summaries" = "two_summary"),
                 selected = "two_samples_data"),

    # === UI for DATA INPUT mode ===
    conditionalPanel(condition = "input.two_sample_options == 'two_samples_data'",

      radioButtons("two_sample_mode", "Select input mode:",
                   choices = c("Two separate numeric variables" = "vars",
                               "One numeric variable + grouping variable" = "group"),
                   selected = "vars"),
checkboxInput("paired", "Paired samples", FALSE),

      uiOutput("two_sample_mode_ui")  # this sub-UI depends on df()
    ),

    # === UI for SUMMARY mode ===
    conditionalPanel(condition = "input.two_sample_options == 'two_summary'",
      withMathJax(),
      br(),
      h4("Group 1"),
      numericInput(inputId = "two.sample.n1", label = "Sample size \\( n_1 \\)", value = 2),
      numericInput(inputId = "two.sample.mean1", label = "Sample mean \\( \\bar{x}_1 \\)", value = 0),
      numericInput(inputId = "two.sample.std1", label = "Sample standard deviation \\( s_1 \\)", value = 1),

      h4("Group 2"),
      numericInput(inputId = "two.sample.n2", label = "Sample size \\( n_2 \\)", value = 2),
      numericInput(inputId = "two.sample.mean2", label = "Sample mean \\( \\bar{x}_2 \\)", value = 0),
      numericInput(inputId = "two.sample.std2", label = "Sample standard deviation \\( s_2 \\)", value = 1),

#      actionButton("run_two_sm", "Run Two Samples Summary")
    )
  )
})

output$two_sample_mode_ui <- renderUI({
  req(mydata())
  df <- mydata()
  num_vars <- names(df)[sapply(df, is.numeric)]
  group_vars <- names(df)[sapply(df, function(x) is.factor(x) || is.character(x))]

  if (input$two_sample_mode == "vars") {
    tagList(
      selectInput("var1", "First Numeric Variable:", choices = num_vars),
      selectInput("var2", "Second Numeric Variable:", choices = num_vars)
    )
  } else if (input$two_sample_mode == "group") {
    tagList(
      selectInput("numvar_grouped", "Select Numeric Variable:", choices = num_vars),
      selectInput("groupvar", "Select Grouping Variable (2 levels):", choices = group_vars)
    )
  }
})

  df <- reactive({ req(mydata()); mydata() })
  
  two.vars <- eventReactive(input$run_two, {
    data <- df()
    mode <- req(input$two_sample_mode)
    
    if (mode == "group") {
      req(input$numvar_grouped, input$groupvar)
      data <- na.omit(data[, c(input$numvar_grouped, input$groupvar)])
      data[[input$groupvar]] <- as.factor(data[[input$groupvar]])
      data[[input$groupvar]] <- droplevels(data[[input$groupvar]])
      levels_group <- levels(data[[input$groupvar]])
      validate(need(length(levels_group) == 2, "Grouping variable must have exactly 2 levels"))
      
      x <- data[data[[input$groupvar]] == levels_group[1], input$numvar_grouped]
      y <- data[data[[input$groupvar]] == levels_group[2], input$numvar_grouped]
    } else {
      req(input$var1, input$var2)
      x <- data[[input$var1]]
      y <- data[[input$var2]]
      levels_group <- c("Group 1", "Group 2")
    }
    
    list(x = as.numeric(x), y = as.numeric(y), group_labels = levels_group)
  })
  
  
  output$UItwo_sample <- renderUI({
  req(two.vars())
  x <- two.vars()$x
  y <- two.vars()$y

  tagList(
    fluidRow(
      column(6, textInput("mu0_two", label = withMathJax("\\( H_0: \\mu_1 - \\mu_2 =  \\)"), value = "0")),
      column(6, sliderInput("p0_two", label = withMathJax("Prior probability \\(P(H_0)\\)"), min = 0, max = 1, value = 0.5, step = 0.01))
    ),
    
    if (!input$paired) {
      m1 <- mean(x, na.rm = TRUE)
      m2 <- mean(y, na.rm = TRUE)
      s1 <- sd(x, na.rm = TRUE)
      s2 <- sd(y, na.rm = TRUE)
      n1 <- sum(!is.na(x))
      n2 <- sum(!is.na(y))
      
      withMathJax(HTML(
        paste0(
          "<table class='table'>",
          "<tr><th></th><th>Group 1</th><th>Group 2</th></tr>",
          "<tr><td>\\( \\bar{x} \\)</td><td>", round(m1, 3), "</td><td>", round(m2, 3), "</td></tr>",
          "<tr><td>\\( s \\)</td><td>", round(s1, 3), "</td><td>", round(s2, 3), "</td></tr>",
          "<tr><td>\\( n \\)</td><td>", n1, "</td><td>", n2, "</td></tr>",
          "</table>"
        )
      ))
    } else {
      d <- x - y
      m <- mean(d, na.rm = TRUE)
      s <- sd(d, na.rm = TRUE)
      n <- sum(!is.na(d))
      
      withMathJax(HTML(
        paste0(
          "<table class='table'>",
          "<tr><td>\\( \\bar{d} = \\)</td><td>", round(m, 3), "</td></tr>",
          "<tr><td>\\( s_d = \\)</td><td>", round(s, 3), "</td></tr>",
          "<tr><td>\\( n = \\)</td><td>", n, "</td></tr>",
          "</table>"
        )
      ))
    },
    
    tableOutput("mean")
  )
})

  output$mean <- renderTable({
    req(two.vars())
    two.sample.t.test.bf(two.vars()$x, two.vars()$y,
                         mu0 = as.numeric(input$mu0_two),
                         p0 = as.numeric(input$p0_two),
                         paired = input$paired,
                         lambda = input$lambda,
                         sigma2d = input$sigma2d)
  }, rownames = TRUE, digits = 5)

   
 output$UItwo_sm <- renderUI({
  tagList(
    fluidRow(
      column(6, numericInput("mu0_sm2", label = withMathJax("\\( H_0: \\mu_1-\\mu_2 =  \\)"), value = 0)),
      column(6, sliderInput("p0_sm2", label = withMathJax("Prior probability \\(P(H_0)\\)"), min = 0, max = 1, value = 0.5, step = 0.01))
    ),
    tableOutput("two_summary_result"),
    tags$hr()
  )
})

output$two_summary_result <- renderTable({
  req(input$two.sample.mean1, input$two.sample.std1, input$two.sample.n1,input$two.sample.mean2, input$two.sample.std2, input$two.sample.n2, input$mu0_sm2, input$p0_sm2)
  
  two.sample.t.test.bf.sm(
    xbar1 = input$two.sample.mean1,
    s21 = (input$two.sample.std1^2),
    n1 = input$two.sample.n1,
    xbar2 = input$two.sample.mean2,
    s22 = (input$two.sample.std2^2),
    n2 = input$two.sample.n2,
    mu0 = input$mu0_sm2,
    p0 = input$p0_sm2)
}, rownames = TRUE, digits = 5)


```

Almodóvar-Rivera, I.A.; Pericchi-Guerra, L.R. An Objective and Robust Bayes Factor for the Hypothesis Test One Sample and Two Population Means. Entropy 2024, 26, 88. [https://doi.org/10.3390/e26010088 ](https://www.mdpi.com/1099-4300/26/1/88).
